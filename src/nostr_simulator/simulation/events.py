"""Event system for discrete event simulation."""

from __future__ import annotations

import heapq
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any
from uuid import uuid4


@dataclass
class Event:
    """Represents a discrete event in the simulation."""

    time: float
    priority: int
    event_id: str = field(default_factory=lambda: str(uuid4()))
    event_type: str = ""
    data: dict[str, Any] = field(default_factory=dict)
    source_id: str | None = None
    target_id: str | None = None

    def __lt__(self, other: Event) -> bool:
        """Compare events for priority queue ordering."""
        if self.time != other.time:
            return self.time < other.time
        return self.priority < other.priority

    def __eq__(self, other: object) -> bool:
        """Check event equality."""
        if not isinstance(other, Event):
            return NotImplemented
        return self.event_id == other.event_id


class EventHandler(ABC):
    """Abstract base class for event handlers."""

    @abstractmethod
    def handle_event(self, event: Event) -> list[Event]:
        """Handle an event and return any resulting events.

        Args:
            event: The event to handle.

        Returns:
            List of new events generated by handling this event.
        """
        pass

    @abstractmethod
    def can_handle(self, event_type: str) -> bool:
        """Check if this handler can handle the given event type.

        Args:
            event_type: The type of event to check.

        Returns:
            True if this handler can handle the event type.
        """
        pass


class EventQueue:
    """Priority queue for managing simulation events."""

    def __init__(self) -> None:
        """Initialize the event queue."""
        self._queue: list[Event] = []
        self._event_counter = 0

    def schedule_event(
        self,
        time: float,
        event_type: str,
        priority: int = 0,
        data: dict[str, Any] | None = None,
        source_id: str | None = None,
        target_id: str | None = None,
    ) -> str:
        """Schedule a new event.

        Args:
            time: When the event should occur.
            event_type: Type of the event.
            priority: Event priority (lower numbers = higher priority).
            data: Additional event data.
            source_id: ID of the event source.
            target_id: ID of the event target.

        Returns:
            The unique event ID.
        """
        if data is None:
            data = {}

        event = Event(
            time=time,
            priority=priority,
            event_type=event_type,
            data=data,
            source_id=source_id,
            target_id=target_id,
        )

        heapq.heappush(self._queue, event)
        self._event_counter += 1

        return event.event_id

    def get_next_event(self) -> Event | None:
        """Get the next event from the queue.

        Returns:
            The next event or None if queue is empty.
        """
        if not self._queue:
            return None
        return heapq.heappop(self._queue)

    def peek_next_event(self) -> Event | None:
        """Peek at the next event without removing it.

        Returns:
            The next event or None if queue is empty.
        """
        if not self._queue:
            return None
        return self._queue[0]

    def cancel_event(self, event_id: str) -> bool:
        """Cancel an event by ID.

        Args:
            event_id: ID of the event to cancel.

        Returns:
            True if event was found and cancelled.
        """
        for _i, event in enumerate(self._queue):
            if event.event_id == event_id:
                # Mark as cancelled by setting a special flag
                event.data["_cancelled"] = True
                return True
        return False

    def size(self) -> int:
        """Get the number of events in the queue.

        Returns:
            Number of events in the queue.
        """
        return len(self._queue)

    def is_empty(self) -> bool:
        """Check if the queue is empty.

        Returns:
            True if the queue is empty.
        """
        return len(self._queue) == 0

    def clear(self) -> None:
        """Clear all events from the queue."""
        self._queue.clear()
        self._event_counter = 0


class EventDispatcher:
    """Dispatches events to appropriate handlers."""

    def __init__(self) -> None:
        """Initialize the event dispatcher."""
        self._handlers: dict[str, list[EventHandler]] = {}
        self._catch_all_handlers: list[EventHandler] = []

    def register_handler(self, event_type: str, handler: EventHandler) -> None:
        """Register a handler for a specific event type.

        Args:
            event_type: The event type to handle.
            handler: The handler to register.
        """
        if event_type not in self._handlers:
            self._handlers[event_type] = []
        self._handlers[event_type].append(handler)

    def register_catch_all_handler(self, handler: EventHandler) -> None:
        """Register a handler for all event types.

        Args:
            handler: The handler to register.
        """
        self._catch_all_handlers.append(handler)

    def unregister_handler(self, event_type: str, handler: EventHandler) -> bool:
        """Unregister a handler for a specific event type.

        Args:
            event_type: The event type.
            handler: The handler to unregister.

        Returns:
            True if handler was found and removed.
        """
        if event_type in self._handlers:
            try:
                self._handlers[event_type].remove(handler)
                return True
            except ValueError:
                pass
        return False

    def dispatch_event(self, event: Event) -> list[Event]:
        """Dispatch an event to appropriate handlers.

        Args:
            event: The event to dispatch.

        Returns:
            List of new events generated by handlers.
        """
        # Skip cancelled events
        if event.data.get("_cancelled", False):
            return []

        new_events: list[Event] = []

        # Dispatch to specific handlers
        if event.event_type in self._handlers:
            for handler in self._handlers[event.event_type]:
                try:
                    handler_events = handler.handle_event(event)
                    new_events.extend(handler_events)
                except Exception as e:
                    # Log error but continue processing
                    print(f"Error in handler {handler}: {e}")

        # Dispatch to catch-all handlers
        for handler in self._catch_all_handlers:
            if handler.can_handle(event.event_type):
                try:
                    handler_events = handler.handle_event(event)
                    new_events.extend(handler_events)
                except Exception as e:
                    # Log error but continue processing
                    print(f"Error in catch-all handler {handler}: {e}")

        return new_events
